/**
 * Conscious Calculator - Emulation of a conscious calculator.
 * Copyright Â© 2019 Malcolm Lett (malcolm.lett at gmail.com)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package lett.malcolm.consciouscalculator.emulator;

import java.time.Clock;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.UUID;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import lett.malcolm.consciouscalculator.emulator.events.ActionEvent;
import lett.malcolm.consciouscalculator.emulator.interfaces.Event;
import lett.malcolm.consciouscalculator.emulator.interfaces.EventEmitter;
import lett.malcolm.consciouscalculator.emulator.interfaces.EventTag;
import lett.malcolm.consciouscalculator.emulator.interfaces.EventsResult;

/**
 * @author Malcolm Lett
 */
public class AttentionAttenuator {
	private static final Logger LOG = LoggerFactory.getLogger(AttentionAttenuator.class);
	
	private static final double DEFAULT_WEIGHTING = 0.5;
	
	private Clock clock;
	private Queue<? extends Object> commandStream;
	private Queue<? extends Object> consciousFeedbackStream;
	private WorkingMemory workingMemory;
	
	// per-interceptor/processor weightings
	private Map<EventEmitter, Double> emitterWeightings = new HashMap<>();
	
	public AttentionAttenuator(
			Clock clock,
			Queue<? extends Object> commandStream,
			Queue<? extends Object> consciousFeedbackStream,
			WorkingMemory workingMemory) {
		this.commandStream = commandStream;
		this.consciousFeedbackStream = consciousFeedbackStream;
		this.workingMemory = workingMemory;
	}
	
	/**
	 * Sets relative weight of an emitter, as compared to the relative weights of other emitters.
	 * @param emitter
	 * @param weighting relative weight in range 0.0 to 1.0; default weight assumed if null
	 * @return this instance, for method chaining
	 */
	public AttentionAttenuator withWeighting(EventEmitter emitter, Double weighting) {
		if (weighting == null) {
			emitterWeightings.remove(emitter);
		}
		else {
			emitterWeightings.put(emitter, weighting);
		}
		return this;
	}

	/**
	 * Decides what to do given:
	 * - raw sense inputs
	 * - events from interceptors
	 * - events from processors
	 * - current state of working memory
	 * 
	 * Outcomes:
	 * - updates state of working memory
	 * @param interceptorResults
	 * 
	 * Prioritization:
	 * - Events are prioritized by their standalone strength
	 * - Events from processors are preferred over events from interceptors
	 * - TODO help decide events based on state of working memory (whatever that means)
	 * - TODO attenuate events based on the strength of the working-memory item or other source that they were based on
	 * 
	 * Attenuation:
	 * - TODO
	 * @param interceptorResults - events generated by interceptors
	 * @param processedEvents - events generated by processors
	 * @param true if changed the state of anything (used for low-level control loop triggering)
	 */
	public boolean act(List<EventsResult> interceptorResults, List<EventsResult> processorResults) {
		// special handling - immediately apply action events
		for (EventsResult processorResult: processorResults) {
			Iterator<Event> eventSetItr = processorResult.emittedEvents().iterator();
			while (eventSetItr.hasNext()) {
				Event event = eventSetItr.next();
				if (event instanceof ActionEvent && event.tags().contains(EventTag.HANDLED)) {
					workingMemory.store(event);
					eventSetItr.remove();
				}
			}
		}
		
		// primary
		EventsResult chosenResult = null;
		for (EventsResult result: processorResults) {
			if (!result.emittedEvents().isEmpty()) {
				if (chosenResult == null || strengthOf(result) > strengthOf(chosenResult)) {
					chosenResult = result;
				}
			}
		}

		// secondary: intercepted events, only pick if strength trumps what was found above 
		for (EventsResult result: interceptorResults) {
			if (!result.emittedEvents().isEmpty()) {
				if (chosenResult == null || strengthOf(result) > strengthOf(chosenResult)) {
					chosenResult = result;
				}
			}
		}
		
		// emit events
		if (chosenResult != null) {
			// prepare for emitting
			// TODO affect scaling by strength of trigger event too
			double scalingFactor = getStrengthScalingFactor(chosenResult.emitter());
			List<Event> events = chosenResult.emittedEvents().stream()
					.map(e -> prepareNewEventForUse(scalingFactor, e))
					.collect(Collectors.toList());

			// adds or update into working memory
			events.forEach(workingMemory::store);
			return true;
		}
		return false;
	}

	/**
	 * Implementation note: the result of this is only used in comparison tests.
	 * Thus it doesn't have to be an accurate global value...what this means
	 * is that we don't need to call {@link #getStrengthScalingFactor(EventEmitter)}.
	 * Because: "a/ave  <  b/ave" is the same as "a < b".
	 * @param result
	 * @return
	 */
	// TODO affect scaling by strength of trigger event too
	private double strengthOf(EventsResult result) {
		return getWeight(result.emitter()) * strengthOf(result.emittedEvents());
	}
	
	private double strengthOf(List<Event> eventSet) {
		return eventSet.get(0).strength();
	}
	
	/**
	 * Prepares a newly created event ready for use within the emulation.
	 * Sets:
	 * - guid
	 * - timestamp
	 * @param event
	 * @return event updated event (possibly after cloning)
	 */
	// TODO may need to be re-used elsewhere
	private Event prepareNewEventForUse(double scalingFactor, Event event) {
		// updates to existing events
		// - don't affect strength
		// - keep guid -- required in order to update existing event
		// - keep timestamp
		if (event.guid() != null && workingMemory.contains(event.guid())) {
			// nothing to do
		}
		
		// new events
		else {
			double suggestedStrength = event.strength();
			
			event.setGuid(UUID.randomUUID().toString());
			event.setTimestamp(clock, clock.instant());
			event.setStrength(suggestedStrength * scalingFactor);
		}
		return event;
	}
	
	/**
	 * Identifies the weight of the provided emitted, relative to all others.
	 * Returns a scaling factor based on those weightings.
	 * @param emitter
	 * @return value in range 0.0 to +inf
	 */
	// TODO probably only do within emitter type: processor vs interceptor.
	private double getStrengthScalingFactor(EventEmitter emitter) {
		// short-cut if no weightings configured
		if (emitterWeightings.isEmpty()) {
			// no scaling factor
			return 1.0;
		}

		double ave = emitterWeightings.values().stream().mapToDouble(v -> v).sum() /
				(double) emitterWeightings.size();
		
		return getWeight(emitter) / ave;
	}
	
	private double getWeight(EventEmitter emitter) {
		Double weight = emitterWeightings.get(emitter);
		return (weight == null) ? DEFAULT_WEIGHTING : weight;
	}
	
}
