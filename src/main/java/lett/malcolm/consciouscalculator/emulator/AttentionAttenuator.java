/**
 * Conscious Calculator - Emulation of a conscious calculator.
 * Copyright Â© 2019 Malcolm Lett (malcolm.lett at gmail.com)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package lett.malcolm.consciouscalculator.emulator;


import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Queue;

import lett.malcolm.consciouscalculator.emulator.events.ActionEvent;
import lett.malcolm.consciouscalculator.emulator.interfaces.Event;
import lett.malcolm.consciouscalculator.emulator.interfaces.EventTag;

/**
 * @author Malcolm Lett
 */
public class AttentionAttenuator {
	private Queue<? extends Object> commandStream;
	private Queue<? extends Object> consciousFeedbackStream;
	private WorkingMemory workingMemory;
	
	public AttentionAttenuator(
			Queue<? extends Object> commandStream,
			Queue<? extends Object> consciousFeedbackStream,
			WorkingMemory workingMemory) {
		this.commandStream = commandStream;
		this.consciousFeedbackStream = consciousFeedbackStream;
		this.workingMemory = workingMemory;
	}

	/**
	 * Decides what to do given:
	 * - raw sense inputs
	 * - events from interceptors
	 * - events from processors
	 * - current state of working memory
	 * 
	 * Outcomes:
	 * - updates state of working memory
	 * @param interceptedEvents
	 * 
	 * Prioritization:
	 * - Events are prioritized by their standalone strength
	 * - Events from processors are preferred over events from interceptors
	 * - TODO help decide events based on state of working memory (whatever that means)
	 * - TODO attenuate events based on the strength of the working-memory item or other source that they were based on
	 * 
	 * Attenuation:
	 * - TODO
	 * @param interceptedEvents - events generated by interceptors
	 * @param processedEvents - events generated by processors
	 * @param true if changed the state of anything (used for low-level control loop triggering)
	 */
	public boolean act(List<Event> interceptedEvents, List<List<Event>> processedEventSets) {
		// special handling - immediately apply action events
		for (List<Event> eventSet: processedEventSets) {
			Iterator<Event> eventSetItr = eventSet.iterator();
			while (eventSetItr.hasNext()) {
				Event event = eventSetItr.next();
				if (event instanceof ActionEvent && event.tags().contains(EventTag.HANDLED)) {
					workingMemory.store(event);
					eventSetItr.remove();
				}
			}
		}
		
		// primary
		List<Event> chosenEventSet = null;
		for (List<Event> eventSet: processedEventSets) {
			if (!eventSet.isEmpty()) {
				if (chosenEventSet == null || strengthOf(eventSet) > strengthOf(chosenEventSet)) {
					chosenEventSet = eventSet;
				}
			}
		}

		// secondary: intercepted events, only pick if strength trumps what was found above 
		for (Event event: interceptedEvents) {
			if (chosenEventSet == null || event.strength() > strengthOf(chosenEventSet)) {
				chosenEventSet = Collections.singletonList(event);
			}
		}

		// emit
		if (chosenEventSet != null) {
			// adds or updates
			chosenEventSet.forEach(workingMemory::store);
			return true;
		}
		return false;
	}
	
	private double strengthOf(List<Event> eventSet) {
		return eventSet.get(0).strength();
	}
	
}
