/**
 * Conscious Calculator - Emulation of a conscious calculator.
 * Copyright Â© 2019 Malcolm Lett (malcolm.lett at gmail.com)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package lett.malcolm.consciouscalculator.emulator;

import java.time.Clock;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Queue;
import java.util.UUID;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import lett.malcolm.consciouscalculator.emulator.events.ActionEvent;
import lett.malcolm.consciouscalculator.emulator.interfaces.Event;
import lett.malcolm.consciouscalculator.emulator.interfaces.EventTag;
import lett.malcolm.consciouscalculator.emulator.interfaces.ProcessorOutput;

/**
 * @author Malcolm Lett
 */
public class AttentionAttenuator {
	private static final Logger LOG = LoggerFactory.getLogger(AttentionAttenuator.class);
	
	private Clock clock;
	private Queue<? extends Object> commandStream;
	private Queue<? extends Object> consciousFeedbackStream;
	private WorkingMemory workingMemory;
	
	public AttentionAttenuator(
			Clock clock,
			Queue<? extends Object> commandStream,
			Queue<? extends Object> consciousFeedbackStream,
			WorkingMemory workingMemory) {
		this.commandStream = commandStream;
		this.consciousFeedbackStream = consciousFeedbackStream;
		this.workingMemory = workingMemory;
	}

	/**
	 * Decides what to do given:
	 * - raw sense inputs
	 * - events from interceptors
	 * - events from processors
	 * - current state of working memory
	 * 
	 * Outcomes:
	 * - updates state of working memory
	 * @param interceptedEvents
	 * 
	 * Prioritization:
	 * - Events are prioritized by their standalone strength
	 * - Events from processors are preferred over events from interceptors
	 * - TODO help decide events based on state of working memory (whatever that means)
	 * - TODO attenuate events based on the strength of the working-memory item or other source that they were based on
	 * 
	 * Attenuation:
	 * - TODO
	 * @param interceptedEvents - events generated by interceptors
	 * @param processedEvents - events generated by processors
	 * @param true if changed the state of anything (used for low-level control loop triggering)
	 */
	public boolean act(List<Event> interceptedEvents, List<ProcessorOutput> processorOutputs) {
		// special handling - immediately apply action events
		for (ProcessorOutput processorOutput: processorOutputs) {
			Iterator<Event> eventSetItr = processorOutput.emittedEvents().iterator();
			while (eventSetItr.hasNext()) {
				Event event = eventSetItr.next();
				if (event instanceof ActionEvent && event.tags().contains(EventTag.HANDLED)) {
					workingMemory.store(event);
					eventSetItr.remove();
				}
			}
		}
		
		// primary
		List<Event> chosenEventSet = null;
		for (ProcessorOutput processorOutput: processorOutputs) {
			if (!processorOutput.emittedEvents().isEmpty()) {
				if (chosenEventSet == null || strengthOf(processorOutput.emittedEvents()) > strengthOf(chosenEventSet)) {
					chosenEventSet = processorOutput.emittedEvents();
				}
			}
		}

		// secondary: intercepted events, only pick if strength trumps what was found above 
		for (Event event: interceptedEvents) {
			if (chosenEventSet == null || event.strength() > strengthOf(chosenEventSet)) {
				chosenEventSet = Collections.singletonList(event);
			}
		}
		
		// emit events
		if (chosenEventSet != null) {
			// prepare for emitting
			chosenEventSet = chosenEventSet.stream().map(this::prepareNewEventForUse).collect(Collectors.toList());

			// adds or update into working memory
			chosenEventSet.forEach(workingMemory::store);
			return true;
		}
		return false;
	}
	
	private double strengthOf(List<Event> eventSet) {
		return eventSet.get(0).strength();
	}
	
	/**
	 * Prepares a newly created event ready for use within the emulation.
	 * Sets:
	 * - guid
	 * - timestamp
	 * @param event
	 * @return event updated event (possibly after cloning)
	 */
	// TODO may need to be re-used elsewhere
	private Event prepareNewEventForUse(Event event) {
		event.setGuid(UUID.randomUUID().toString());
		event.setTimestamp(clock.instant());
		return event;
	}
	
}
