package lett.malcolm.consciouscalculator.emulator.events;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * This class defines rules around what data types and structures may be used in
 * {@code Event.data} and other similar generic data values.
 * 
 * Generic data values may only be one of the following types, which may be recursive:
 * <ul>
 * <li> String
 * <li> Integer
 * <li> Double
 * <li> Boolean
 * <li> List
 * <li> Set
 * <li> Map<by string>
 * </ul>
 * 
 * Other rules for data types:
 * <ul>
 * <li> Cycles and graphs are permitted, but all referenced objects should exist within the data structure -- cannot be verified automatically
 * </ul>
 * 
 * TODO add support for Enums? Can't reliably clone once persisted to json.
 */
public class DataRules {
	private static final int EXPECTED_MAX_NUMBER_OF_OBJECTS = 100;
	private static final Set<Class<?>> IMMUTABLE_TYPES = new HashSet<Class<?>>();
	private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
	
	static {
		IMMUTABLE_TYPES.add(String.class);
		IMMUTABLE_TYPES.add(Integer.class);
		IMMUTABLE_TYPES.add(Double.class);
		IMMUTABLE_TYPES.add(Boolean.class);
	}

	/**
	 * Checks that the object meets the data rules.
	 * @param obj
	 * @throws IllegalArgumentException if not valid
	 */
	public static void assertValid(Object obj) {
		assertValid(obj, new CycleHandler());
	}
	
	/**
	 * Calculates the total size of the given object.
	 * Provides an indicative number in a unified way that works across all data types.
	 * For example, used to help set {@code Event.size}.
	 * 
	 * Not a real size, so don't try to use it to determine the number of items an a collection.
	 * @param obj
	 * @return
	 */
	public static int measureSize(Object obj) {
		return measureSize(obj, new CycleHandler());
	}
	
	/**
	 * Returns a deep clone of the given object.
	 * @param obj
	 * @return
	 */
	public static <T> T clone(T obj) {
		return clone(obj, new CycleHandler());
	}
	
	/**
	 * Generates a convenient string representation, primarily intended for use
	 * in logging.
	 * Similar to {@link #marshal(Object)}, but uses a simplified notation
	 * for simple scalar types, that looses the exact data type in some cases.
	 * Uses the result of {@link #marshal(Object)} for collection and complex data structures.
	 * 
	 * Strings returned by this method <em>cannot</em> be unmarshalled back to the original data structure.
	 * @param obj
	 * @return
	 */
	public static String stringOf(Object obj) {
		if (obj == null) {
			return "null";
		}
		else if (obj instanceof Boolean) {
			return Boolean.TRUE.equals(obj) ? "true" : "false";
		}
		else if (IMMUTABLE_TYPES.contains(obj.getClass())) {
			return String.valueOf(obj);
		}
		else {
			return marshal(obj);
		}
	}
	
	/**
	 * Marshals simple scalar types to a deterministic string representation,
	 * and everything else to JSON string, in compact mode.
	 * 
	 * The marshaled format can be reliably converted back to original data structure
	 * via a call to {@link #unmarshal(String)}.
	 * @param obj
	 * @return
	 */
	public static String marshal(Object obj) {
		assertValid(obj);
		try {
			return OBJECT_MAPPER.writeValueAsString(obj);
		} catch (JsonProcessingException e) {
			// unexpected
			throw new IllegalArgumentException("Unable to marshal object: " + e.getMessage(), e);
		}
	}

	/**
	 * Unmarshals from strings generated by {@link #marshal(Object)}.
	 * @param json
	 * @return
	 */
	public static Object unmarshal(String json) {
		try {
			return OBJECT_MAPPER.readValue(json, Object.class);
		} catch (IOException e) {
			// unexpected
			throw new IllegalArgumentException("Unable to unmarshal string: " + json, e);
		}
	}
	
	/**
	 * Recursively checks that the object meets the data rules.
	 * @param obj
	 * @throws IllegalArgumentException if not valid
	 */
	@SuppressWarnings("unchecked")
	private static void assertValid(Object obj, CycleHandler cycles) {
		if (obj == null) {
			return;
		}
		
		if (!cycles.observeAndIsDuplicate(obj)) {
			if (!isValidImmediateType(obj)) {
				throw new IllegalArgumentException("Objects of type " + obj.getClass().getName()+" not permitted");
			}
			
			// recurse
			if (obj instanceof List) {
				for (Object item: (List<Object>) obj) {
					assertValid(item, cycles);
				}
			}
			else if (obj instanceof Set) {
				for (Object item: (Set<Object>) obj) {
					assertValid(item, cycles);
				}
			}
			else if (obj instanceof Map) {
				for (Map.Entry<String,Object> entry: ((Map<String,Object>) obj).entrySet()) {
					assertValid(entry.getValue(), cycles);
				}
			}
		}
	}
	
	/**
	 * Recursively calculates the total size of the given object.
	 * @param obj
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private static int measureSize(Object obj, CycleHandler cycles) {
		if (obj == null) {
			return 0;
		}
		else if (cycles.observeAndIsDuplicate(obj)) {
			// 1 unit for a reference
			return 1;
		}
		else {
			if (obj instanceof String) {
				// one 'unit' for each group of 3 characters
				return (int) Math.ceil(((String) obj).length() / 3.0);
			}
			else if (IMMUTABLE_TYPES.contains(obj.getClass())) {
				return 1;
			}
			
			// recursive types
			// (1 for the collection itself)
			int size = 1;
			
			// recurse
			if (obj instanceof List) {
				for (Object item: (List<Object>) obj) {
					size += measureSize(item, cycles);
				}
			}
			else if (obj instanceof Set) {
				for (Object item: (List<Object>) obj) {
					size += measureSize(item, cycles);
				}
			}
			else if (obj instanceof Map) {
				for (Map.Entry<String,Object> entry: ((Map<String,Object>) obj).entrySet()) {
					size += measureSize(entry.getValue(), cycles);
				}
			}
			else {
				throw new IllegalArgumentException("Objects of type " + obj.getClass().getName()+" not permitted");
			}
			
			return size;
		}
	}
	
	/**
	 * Recursively generates a deep clone of the given object.
	 * @param obj
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private static <T> T clone(T obj, CycleHandler cycles) {
		if (obj == null) {
			return null;
		}
		
		// handle cycles
		Object clone = cycles.getObservedMirror(obj);
		if (clone != null) {
			return (T) clone;
		}

		// clone
		if (IMMUTABLE_TYPES.contains(obj.getClass())) {
			// immutable, so no need to clone
			clone = obj;
		}
		else if (obj instanceof List) {
			List<Object> cloneList = new ArrayList<>();
			for (Object item: (List<Object>) obj) {
				cloneList.add(clone(item, cycles));
			}
			clone = cloneList;
		}
		else if (obj instanceof Set) {
			Set<Object> cloneSet = new HashSet<>();
			for (Object item: (List<Object>) obj) {
				cloneSet.add(clone(item, cycles));
			}
			clone = cloneSet;
		}
		else if (obj instanceof Map) {
			Map<String,Object> cloneMap = new HashMap<>();
			for (Map.Entry<String,Object> entry: ((Map<String,Object>) obj).entrySet()) {
				cloneMap.put(entry.getKey(), clone(entry.getValue(), cycles));
			}
			clone = cloneMap;
		}
		else {
			throw new IllegalArgumentException("Objects of type " + obj.getClass().getName()+" not permitted");
		}
		
		// track and return
		cycles.observeMirror(obj, clone);
		return (T) clone;
	}
	
	/**
	 * Uses object reference for identity.
	 * 
	 * Works in two modes:
	 * - object only
	 * - map from 'object' to 'mirror'
	 * 
	 * Where docs refer to 'object', they always mean on the 'key' side of the map.
	 */
	private static class CycleHandler {
		private Map<Object, Object> observed = new IdentityHashMap<>(EXPECTED_MAX_NUMBER_OF_OBJECTS);
		
		/**
		 * Records that an obj has been observed, and indicates whether it was previously observed.
		 * Always ignores nulls.
		 * @param obj
		 * @return
		 */
		public boolean observeAndIsDuplicate(Object obj) {
			if (obj != null) {
				return observed.put(obj, obj) != null;
			}
			return false;
		}

		/**
		 * Always ignores nulls.
		 * @param obj
		 * @param mirror
		 */
		public void observeMirror(Object obj, Object mirror) {
			if (obj != null) {
				observed.put(obj, mirror);
			}
		}
		
		public Object getObservedMirror(Object obj) {
			return observed.get(obj);
		}
	}

	/**
	 * Non-recursive.
	 * @param obj
	 * @return
	 */
	private static boolean isValidImmediateType(Object obj) {
		if (IMMUTABLE_TYPES.contains(obj.getClass())) {
			return true;
		}
		if (obj instanceof List) {
			return true;
		}
		if (obj instanceof Set) {
			return true;
		}
		if (obj instanceof Map) {
			return true;
		}
		return false;
	}
}
